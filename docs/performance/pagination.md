# ページネーション

## 1.1 オフセット & リミット方式

**概要**
従来型のページネーション方式。`offset`（開始位置）と`limit`（取得件数）を指定してデータを取得する。

**リクエスト例**
```
GET /api/users?limit=10&offset=20  → 21件目から30件目を取得
```

**Laravelでの実装方法**
- `skip()` と `take()` メソッドを組み合わせて使用
- Laravel標準の `paginate()` メソッドも利用可能（ページ番号ベース）

```php
$users = User::query()->skip($offset)->take($limit)->get();
```

**メリット**
- 実装がシンプル
- 任意のページへ直接ジャンプ可能
- 総件数の取得が容易

**デメリット**
- offset値が大きくなると性能が劣化（100万件スキップ等は非常に遅い）
- リアルタイムでデータが追加・削除されると、ページ間でデータのズレが発生する可能性

**適用場面**
小〜中規模のデータセット、管理画面など総件数表示が必要な場合

---

## 1.2 カーソルベース方式

**概要**
最後に取得したレコードの識別子（カーソル）を基準に、次のデータセットを取得する方式。大規模データに適している。

**リクエスト例**
```
GET /api/users?cursor=eyJpZCI6MTB9  → カーソル位置以降のデータを取得
```

**Laravelでの実装方法**
Laravel標準の `cursorPaginate()` メソッドを使用するのが最も簡単。

```php
$users = User::query()->orderBy('id')->cursorPaginate(15);
```

**カーソルの仕組み**
- カーソルはBase64エンコードされたJSON（例：`{"id":10,"_pointsToNextItems":true}`）
- クライアントは次ページ取得時にこのカーソル値をそのまま送信

**メリット**
- データ量に関わらず一定のパフォーマンス
- リアルタイムデータでも一貫性を保てる
- インデックスを効率的に活用できる

**デメリット**
- 任意のページへのジャンプ不可（前後移動のみ）
- 総件数取得には別クエリが必要
- 実装がやや複雑

**複合カーソルについて**
複数カラムでソートする場合（例：作成日時＋ID）、両方の値をカーソルに含める必要がある。これにより同一日時のレコードでも正確にページングできる。

**適用場面**
無限スクロールUI、大規模データセット、SNSのタイムライン表示など

---

## 実装時のチェックリスト

- [ ] データ規模に応じた方式を選択（小規模→オフセット、大規模→カーソル）
- [ ] per_page/limit の上限値を設定（例：max 100）
- [ ] ソート対象カラムにインデックスを設定

---

## 方式選択の早見表

| 要件 | 推奨方式 |
|------|---------|
| 管理画面のテーブル表示 | オフセット + ページ番号 |
| 無限スクロールUI | カーソルベース |
| 100万件以上のデータ | カーソルベース必須 |
| モバイルアプリ向けAPI | カーソル + フィールド選択 |


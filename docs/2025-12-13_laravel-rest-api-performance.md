# Laravel 12 REST API パフォーマンス最適化マニュアル

## 1. ページネーション

### 1.1 オフセット & リミット方式

**概要**
従来型のページネーション方式。`offset`（開始位置）と`limit`（取得件数）を指定してデータを取得する。

**リクエスト例**
```
GET /api/users?limit=10&offset=20  → 21件目から30件目を取得
```

**Laravelでの実装方法**
- `skip()` と `take()` メソッドを組み合わせて使用
- Laravel標準の `paginate()` メソッドも利用可能（ページ番号ベース）

```php
$users = User::query()->skip($offset)->take($limit)->get();
```

**メリット**
- 実装がシンプル
- 任意のページへ直接ジャンプ可能
- 総件数の取得が容易

**デメリット**
- offset値が大きくなると性能が劣化（100万件スキップ等は非常に遅い）
- リアルタイムでデータが追加・削除されると、ページ間でデータのズレが発生する可能性

**適用場面**
小〜中規模のデータセット、管理画面など総件数表示が必要な場合

---

### 1.2 カーソルベース方式

**概要**
最後に取得したレコードの識別子（カーソル）を基準に、次のデータセットを取得する方式。大規模データに適している。

**リクエスト例**
```
GET /api/users?cursor=eyJpZCI6MTB9  → カーソル位置以降のデータを取得
```

**Laravelでの実装方法**
Laravel標準の `cursorPaginate()` メソッドを使用するのが最も簡単。

```php
$users = User::query()->orderBy('id')->cursorPaginate(15);
```

**カーソルの仕組み**
- カーソルはBase64エンコードされたJSON（例：`{"id":10,"_pointsToNextItems":true}`）
- クライアントは次ページ取得時にこのカーソル値をそのまま送信

**メリット**
- データ量に関わらず一定のパフォーマンス
- リアルタイムデータでも一貫性を保てる
- インデックスを効率的に活用できる

**デメリット**
- 任意のページへのジャンプ不可（前後移動のみ）
- 総件数取得には別クエリが必要
- 実装がやや複雑

**複合カーソルについて**
複数カラムでソートする場合（例：作成日時＋ID）、両方の値をカーソルに含める必要がある。これにより同一日時のレコードでも正確にページングできる。

**適用場面**
無限スクロールUI、大規模データセット、SNSのタイムライン表示など

---

## 2. フィルタリング

### 2.1 デフォルトレスポンスの軽量化

**基本原則**
APIのデフォルトレスポンスは必要最小限のフィールドのみを返す。追加情報は明示的なリクエスト時のみ返却する。

**実装アプローチ**

1. **API Resourceでの制御**: `toArray()` メソッド内でリクエストパラメータに応じてフィールドを動的に追加

2. **リレーションの遅延ロード**: `include_posts=true` のようなパラメータがある場合のみリレーションをロード（N+1問題対策にも有効）

```php
// リクエストパラメータに応じてリレーションをロード
if ($request->boolean('include_posts')) {
    $query->with('posts');
}
```

**効果**
- レスポンスサイズの削減
- シリアライズ処理の軽減
- ネットワーク転送量の削減

---

### 2.2 Sparse Fieldsets（フィールド選択）

**概要**
クライアントが必要なフィールドのみを指定して取得できる仕組み。JSON:API仕様などで採用されている。

**リクエスト例**
```
GET /api/users?fields=id,name,email
```

**実装のポイント**

1. **許可リストの定義**: 返却可能なフィールドをホワイトリストで管理
2. **デフォルト値の設定**: fieldsパラメータ未指定時は最小限のフィールドを返却
3. **セキュリティ考慮**: 機密フィールド（パスワードハッシュ等）は許可リストに含めない

```php
$allowedFields = ['id', 'name', 'email', 'created_at'];
$requestedFields = explode(',', $request->input('fields', 'id,name'));
$selectedFields = array_intersect($requestedFields, $allowedFields);
```

---

### 2.3 検索・フィルタリング

**一般的なフィルタパラメータ**

| パラメータ | 用途 | 例 |
|-----------|------|-----|
| `status` | ステータス絞り込み | `?status=active` |
| `search` | キーワード検索 | `?search=john` |
| `sort` | ソート順（-で降順） | `?sort=-created_at` |
| `created_after` | 日時範囲 | `?created_after=2024-01-01` |

**実装のベストプラクティス**

- **Filterクラスの分離**: フィルタリングロジックを専用クラスに切り出し、コントローラーをシンプルに保つ
- **ソートの安全性**: 許可されたカラムのみソート可能にする（SQLインジェクション対策）
- **`when()` メソッドの活用**: パラメータの有無で条件を動的に構築

```php
$query->when($request->filled('status'), fn($q) => 
    $q->where('status', $request->input('status'))
);
```

---

## 3. キャッシュ活用

### 3.1 クライアント側キャッシュ（HTTPヘッダー）

**Cache-Control ヘッダー**

ブラウザやCDNにキャッシュ動作を指示するヘッダー。

| ディレクティブ | 説明 |
|--------------|------|
| `public` | CDN等の共有キャッシュに保存可 |
| `private` | ブラウザのみキャッシュ可（認証済みユーザー向け） |
| `max-age=N` | N秒間キャッシュを有効とする |
| `s-maxage=N` | CDN専用のmax-age |
| `no-store` | キャッシュ保存禁止（機密データ向け） |

```php
return response()->json($data)
    ->header('Cache-Control', 'public, max-age=60, s-maxage=120');
```

**ETag（エンティティタグ）**

データの「指紋」となるハッシュ値。クライアントは `If-None-Match` ヘッダーでこの値を送信し、データが変更されていなければサーバーは `304 Not Modified` を返す。

**動作フロー**
1. サーバー: レスポンスに `ETag: "abc123"` を付与
2. クライアント: 次回リクエストで `If-None-Match: "abc123"` を送信
3. サーバー: データ未変更なら `304` を返却（本文なし）

```php
$etag = md5($user->updated_at->timestamp);
if ($request->header('If-None-Match') === "\"{$etag}\"") {
    return response()->noContent(304);
}
```

**Last-Modified ヘッダー**

ETagと同様の条件付きリクエストを日時ベースで実現。`If-Modified-Since` ヘッダーと組み合わせて使用。

**効果**
- 不要なデータ転送の削減
- サーバー負荷の軽減
- ユーザー体験の向上（高速なレスポンス）

---

### 3.2 サーバー側キャッシュ

**基本的なキャッシュパターン**

`Cache::remember()` を使用し、キャッシュがあれば返却、なければDBから取得してキャッシュに保存。

```php
$data = Cache::remember($cacheKey, $ttl, function () {
    return User::all(); // キャッシュミス時のみ実行
});
```

**キャッシュキーの設計**

クエリパラメータを含めたユニークなキーを生成することが重要。

```
users:list:abc123  （abc123はクエリパラメータのハッシュ）
users:show:42      （ユーザーID42の詳細）
```

**タグベースキャッシュ（Redis/Memcached）**

関連するキャッシュをグループ化し、一括で無効化できる仕組み。

```php
// 保存時にタグを付与
Cache::tags(['users', 'list'])->remember($key, $ttl, $callback);

// ユーザー更新時に関連キャッシュを一括クリア
Cache::tags(['users'])->flush();
```

**キャッシュ無効化のタイミング**

Model Observerを活用し、データ更新時に自動でキャッシュをクリア。

```php
// UserObserver
public function saved(User $user): void
{
    Cache::forget("users:show:{$user->id}");
    Cache::tags(['users', 'list'])->flush();
}
```

**キャッシュドライバの選択**

| ドライバ | タグサポート | 用途 |
|---------|------------|------|
| file | ✕ | 開発環境 |
| redis | ◯ | 本番環境推奨 |
| memcached | ◯ | 本番環境 |
| database | ✕ | 小規模本番 |

---

## 4. 実装時のチェックリスト

### ページネーション
- [ ] データ規模に応じた方式を選択（小規模→オフセット、大規模→カーソル）
- [ ] per_page/limit の上限値を設定（例：max 100）
- [ ] ソート対象カラムにインデックスを設定

### フィルタリング
- [ ] デフォルトレスポンスを軽量に設計
- [ ] 許可フィールドのホワイトリストを定義
- [ ] フィルタ・ソートのパラメータをバリデーション

### キャッシュ
- [ ] 適切なCache-Controlヘッダーを設定
- [ ] 認証済みユーザー向けには `private` を使用
- [ ] 機密データには `no-store` を使用
- [ ] サーバーキャッシュのTTLを適切に設定
- [ ] データ更新時のキャッシュ無効化を実装

### 計測・監視
- [ ] レスポンスタイムをヘッダーに含める（`X-Response-Time`）
- [ ] 遅いリクエストをログに記録
- [ ] キャッシュヒット率を監視

---

## 5. 方式選択の早見表

| 要件 | 推奨方式 |
|------|---------|
| 管理画面のテーブル表示 | オフセット + ページ番号 |
| 無限スクロールUI | カーソルベース |
| 100万件以上のデータ | カーソルベース必須 |
| モバイルアプリ向けAPI | カーソル + フィールド選択 |
| 公開API（CDN活用） | Cache-Control + ETag |
| ユーザー固有データ | private + サーバーキャッシュ |
| リアルタイム性が必要 | キャッシュ短め or 無効化頻繁に |
